<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Responsive Musical Keyboard (WebAudio)</title>
<style>
  :root{
    --bg:#0f1724; --panel:#0b1220; --white:#f6f7fb; --muted:#9aa4b2;
    --keyWhite:#fff; --keyBlack:#222; --accent:#2dd4bf;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; display:flex; gap:18px; align-items:center; justify-content:center;
    background: linear-gradient(180deg,#071023 0%, #082033 100%); color:var(--white); font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
    padding:18px;
  }

  .wrap{
    width:100%;
    max-width:1100px;
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
    border-radius:12px;
    padding:16px;
    box-shadow:0 8px 40px rgba(2,6,23,0.6);
  }

  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  h1{font-size:1.05rem;margin:0}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

  .control {
    background:transparent;border:1px solid rgba(255,255,255,0.06);
    padding:8px;border-radius:8px;color:var(--white);display:inline-flex;gap:8px;align-items:center;
  }
  .control label{font-size:0.85rem;color:var(--muted)}
  .btn{cursor:pointer;padding:6px 10px;border-radius:8px;border:none;background:var(--accent);color:#04202a;font-weight:600}
  .small{font-size:0.85rem;color:var(--muted)}

  /* Keyboard container - NO horizontal scrollbar */
  .keyboard-wrap{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:10px;padding:12px;overflow:hidden;
  }
  .keys{
    display:flex;
    align-items:flex-end;
    gap:0;
    user-select:none;
    touch-action:none; /* important for multi-touch */
    -webkit-user-select:none;
    -webkit-touch-callout:none;
    padding-bottom:6px;
    /* NO scrollbars: we'll auto-resize keys to fit */
    overflow-x:hidden;
    overflow-y:visible;
  }

  /* Stacked (vertical) layout class applied to keyboard-wrap when toggled */
  .keyboard-wrap.stacked .keys{
    flex-direction:column;
    align-items:stretch;
  }

  /* white keys */
  .key{
    position:relative;
    /* default flex-basis will be set by JS to fit container */
    flex: 0 0 56px; /* fallback width */
    height:200px;
    border:1px solid rgba(0,0,0,0.12);
    background:var(--keyWhite);
    border-radius:6px;
    margin-right:1px;
    display:flex;align-items:flex-end;justify-content:center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.25);
    color:#101218;font-weight:600;
  }
  .key.label{font-size:13px;padding-bottom:10px}
  .key.active{background:linear-gradient(180deg,#ffe6b3,#ffd27a);transform:translateY(2px)}
  /* black keys */
  .key.black{
    position:relative;
    /* width set by JS as percentage of white key width */
    flex: 0 0 36px;
    height:130px;
    background:var(--keyBlack);
    color:#fff;
    margin-left:-18px;
    margin-right:-18px;
    z-index:3;
    border-radius:6px;
    box-shadow: 0 6px 12px rgba(0,0,0,0.6);
    display:flex;align-items:flex-end;justify-content:center;
  }
  .key.black.active{background:#333; transform:translateY(2px);}

  /* responsive: larger keys on small screens, but no scroll (JS will adapt) */
  @media (max-width:700px){
    .key{height:240px}
    .key.black{height:150px}
  }

  /* Stacked (vertical) key sizes when keyboard-wrap has .stacked */
  .keyboard-wrap.stacked .key{
    /* full width; height reduced for vertical stacking */
    flex: 0 0 auto;
    width: 100%;
    height: 64px;
    margin: 6px 0;
  }
  .keyboard-wrap.stacked .key.black{
    /* black keys appear as narrower overlay on stacked layout */
    width: 28%;
    height: 42px;
    margin-left: -14%;
    margin-right: 0;
    align-self:flex-start;
  }

  /* extra: show octave label bottom */
  .noteLabel{font-size:12px;padding:8px 4px;color:rgba(0,0,0,0.65)}
  .black .noteLabel{color:#fff}

  /* bottom help */
  .help{margin-top:12px;font-size:0.9rem;color:var(--muted)}
  .kbd{display:inline-block;background:rgba(255,255,255,0.05);padding:4px 8px;border-radius:6px;margin-left:6px}

  /* make keyboard occupy full width if many keys */
  .keys:focus{outline:none}
</style>
</head>
<body>

<div class="wrap" role="application" aria-label="Musical keyboard">
  <header>
    <h1>üéπ Responsive Musical Keyboard ‚Äî WebAudio</h1>
    <div class="controls">
      <div class="control">
        <label>Octave</label>
        <button id="octDown" class="btn" title="Lower octave">‚àí</button>
        <div id="octLabel" class="small" style="min-width:28px;text-align:center">4</div>
        <button id="octUp" class="btn" title="Higher octave">+</button>
      </div>

      <div class="control">
        <label>Volume</label>
        <input id="volume" type="range" min="0" max="1" step="0.01" value="0.60" />
      </div>

      <div class="control">
        <label>Sustain</label>
        <input id="sustain" type="checkbox" />
      </div>

      <div class="control" style="padding:6px">
        <button id="allStop" class="btn">Stop All</button>
      </div>

      <div class="control" style="padding:6px">
        <button id="toggleView" class="btn" title="Toggle stacked/horizontal view">Toggle View</button>
      </div>
    </div>
  </header>

  <div id="keyboardWrap" class="keyboard-wrap">
    <div id="keys" class="keys" tabindex="0" aria-label="Piano keys (click or touch to play)"></div>
  </div>

  <div class="help">
    Play with mouse/touch or use your computer keyboard. Mapped keys: <span class="kbd">Z X C V B N M , . /</span> (white) and <span class="kbd">S D G H J</span> (black) ‚Äî this is one layout starting at C. Use octave ¬± to shift. The keyboard auto-resizes to fit the container without scrollbars. Use Toggle View to stack keys vertically on mobile if you prefer.
  </div>
<div align=center><a href="https://zodiaclab.github.io/microapps/" style="color:var(--accent);text-decoration:none">‚Üê Back / Home</a></div>

</div>

<script>
/* ====== Simple WebAudio synth keyboard (modified to auto-fit width and provide stacked view) ====== */

/* NOTE_SEQUENCE kept unchanged from your original */
const NOTE_SEQUENCE = [
  {name:'C',  key:'Z',  type:'white',  semitone:0},
  {name:'C#', key:'S',  type:'black',  semitone:1},
  {name:'D',  key:'X',  type:'white',  semitone:2},
  {name:'D#', key:'D',  type:'black',  semitone:3},
  {name:'E',  key:'C',  type:'white',  semitone:4},
  {name:'F',  key:'V',  type:'white',  semitone:5},
  {name:'F#', key:'G',  type:'black',  semitone:6},
  {name:'G',  key:'B',  type:'white',  semitone:7},
  {name:'G#', key:'H',  type:'black',  semitone:8},
  {name:'A',  key:'N',  type:'white',  semitone:9},
  {name:'A#', key:'J',  type:'black',  semitone:10},
  {name:'B',  key:'M',  type:'white',  semitone:11},
  {name:'C2', key:',', type:'white', semitone:12}
];

const keysContainer = document.getElementById('keys');
const keyboardWrap = document.getElementById('keyboardWrap');
const octLabel = document.getElementById('octLabel');
let baseOctave = 4; // middle C = C4
octLabel.textContent = baseOctave;

const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
const master = {volume: parseFloat(document.getElementById('volume').value)};

/* active notes map: identifier -> {osc, gain, env} */
const activeNotes = new Map();

/* utility: midi number to frequency */
function midiToFreq(m){
  return 440 * Math.pow(2, (m - 69) / 12);
}

/* create key elements */
function buildKeys(octave){
  keysContainer.innerHTML = '';
  const octavesToShow = 2; // adjustable
  for (let o=0;o<octavesToShow;o++){
    for (const n of NOTE_SEQUENCE){
      const isBlack = n.type === 'black';
      const el = document.createElement('div');
      el.className = 'key' + (isBlack ? ' black' : '');
      el.dataset.name = n.name.replace('2',''); // label small
      const semitone = n.semitone + o*12;
      const midi = 12 * (octave + o) + semitone; // C at octave = 12*octave
      el.dataset.midi = midi;
      const label = document.createElement('div');
      label.className = 'noteLabel';
      const displayName = n.name.replace('2','');
      label.innerHTML = `<div style="font-size:12px">${displayName}</div><div style="font-size:11px;color:rgba(255,255,255,0.6)">${String(midi)}</div>`;
      el.appendChild(label);
      attachPointerHandlers(el);
      keysContainer.appendChild(el);
    }
  }
  // after building, adjust sizes to fit container without scrollbars
  requestAnimationFrame(adjustKeySizes);
}

/* Attach pointer events to a key element (works for multi-touch) */
function attachPointerHandlers(el){
  el.addEventListener('pointerdown', e => {
    e.preventDefault();
    el.setPointerCapture(e.pointerId);
    const id = `${e.pointerId}:${el.dataset.midi}`;
    noteOn(Number(el.dataset.midi), id);
  });
  el.addEventListener('pointerup', e => {
    e.preventDefault();
    const id = `${e.pointerId}:${el.dataset.midi}`;
    el.releasePointerCapture && el.releasePointerCapture(e.pointerId);
    noteOff(Number(el.dataset.midi), id);
  });
  el.addEventListener('pointercancel', e => {
    const id = `${e.pointerId}:${el.dataset.midi}`;
    noteOff(Number(el.dataset.midi), id);
  });
  // pointerleave: if pointer leaves while pressed, release
  el.addEventListener('pointerleave', e => {
    if (e.pressure > 0) {
      const id = `${e.pointerId}:${el.dataset.midi}`;
      noteOff(Number(el.dataset.midi), id);
    }
  });
}

/* start audio context on first interaction */
function ensureAudioCtx(){
  if (!audioCtx){
    audioCtx = new AudioCtx();
  }
}

/* play note */
function noteOn(midi, id){
  ensureAudioCtx();
  if (activeNotes.has(id)) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = 9000;

  osc.type = 'sine'; // smooth default (changeable)
  osc.frequency.value = midiToFreq(midi);
  // simple ADSR
  gain.gain.value = 0;
  const attack = 0.01;
  const decay = 0.12;
  const sustainLevel = document.getElementById('sustain').checked ? 0.7 : 0.4;
  const release = 0.4;
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(master.volume, now + attack);
  gain.gain.linearRampToValueAtTime(master.volume * sustainLevel, now + attack + decay);

  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);

  osc.start();
  activeNotes.set(id, {osc,gain,filter,release});
  highlightKey(midi, true);
}

/* stop note (release) */
function noteOff(midi, id){
  const obj = activeNotes.get(id);
  if (!obj) return;
  const now = audioCtx.currentTime;
  obj.gain.gain.cancelScheduledValues(now);
  obj.gain.gain.setValueAtTime(obj.gain.gain.value, now);
  obj.gain.gain.linearRampToValueAtTime(0, now + obj.release);
  // stop oscillator after release
  setTimeout(() => {
    try{
      obj.osc.stop();
      obj.osc.disconnect();
      obj.gain.disconnect();
      obj.filter.disconnect();
    } catch(e){}
  }, (obj.release + 0.05) * 1000);
  activeNotes.delete(id);
  highlightKey(midi, false);
}

/* highlight key element when active */
function highlightKey(midi, on){
  const list = Array.from(document.querySelectorAll('.key'));
  for (const k of list){
    if (Number(k.dataset.midi) === midi){
      if (on) k.classList.add('active'); else k.classList.remove('active');
    }
  }
}

/* ALL STOP */
document.getElementById('allStop').addEventListener('click', ()=> {
  for (const id of Array.from(activeNotes.keys())){
    const midi = Number(id.split(':')[1]);
    noteOff(midi, id);
  }
});

/* octave controls */
document.getElementById('octUp').addEventListener('click', ()=> {
  baseOctave = Math.min(7, baseOctave + 1);
  octLabel.textContent = baseOctave;
  buildKeys(baseOctave);
});
document.getElementById('octDown').addEventListener('click', ()=> {
  baseOctave = Math.max(1, baseOctave - 1);
  octLabel.textContent = baseOctave;
  buildKeys(baseOctave);
});

/* volume control */
document.getElementById('volume').addEventListener('input', (e)=> {
  master.volume = parseFloat(e.target.value);
});

/* keyboard mapping for convenience: map computer keys to nearest note of first octave shown */
const keyDownIds = new Map();
window.addEventListener('keydown', (ev)=> {
  const key = ev.key.toUpperCase();
  if (ev.repeat) return;
  // find sequence index for this key
  const seqIndex = NOTE_SEQUENCE.findIndex(n => n.key === key);
  if (seqIndex >= 0){
    // use first octave (octave offset 0) to compute midi
    const seq = NOTE_SEQUENCE[seqIndex];
    const midi = 12*(baseOctave) + seq.semitone;
    const id = `kb:${key}`;
    if (!keyDownIds.has(id)){
      noteOn(midi, id);
      keyDownIds.set(id, midi);
    }
  }
});
window.addEventListener('keyup', (ev)=> {
  const key = ev.key.toUpperCase();
  const id = `kb:${key}`;
  if (keyDownIds.has(id)){
    const midi = keyDownIds.get(id);
    noteOff(midi, id);
    keyDownIds.delete(id);
  }
});

/* Build and focus */
buildKeys(baseOctave);
keysContainer.focus();

/* Prevent scrolling while touching piano on mobile - but we need container to not scroll */
let touching = false;
keysContainer.addEventListener('touchstart', e => { touching = true; }, {passive:false});
keysContainer.addEventListener('touchend', e => { touching = false; }, {passive:false});

/* ---------------------------
   AUTO-ADJUST KEY SIZES (NO SCROLLBAR)
   Logic:
   - Count white keys in the container
   - Compute whiteKeyWidth = floor((containerWidth - totalGap) / whiteKeyCount)
   - Set each white key flex-basis to that width
   - Set each black key width = Math.round(whiteKeyWidth * 0.62)
   - For stacked (vertical) layout: let CSS handle full-width; we still set heights if needed
   ---------------------------*/
function adjustKeySizes(){
  const wrapRect = keyboardWrap.getBoundingClientRect();
  const containerWidth = Math.max(100, Math.floor(wrapRect.width));
  const isStacked = keyboardWrap.classList.contains('stacked');
  const keyEls = Array.from(keysContainer.children);

  if (isStacked){
    // In stacked mode, just ensure keys fill width; let CSS manage heights
    keyEls.forEach(k => {
      k.style.flex = '0 0 auto';
      k.style.width = '100%';
      // black keys narrower overlay
      if (k.classList.contains('black')){
        k.style.width = '28%';
        k.style.marginLeft = '-14%';
        k.style.marginRight = '0';
      } else {
        k.style.marginRight = '0';
        k.style.marginLeft = '0';
      }
    });
    return;
  }

  // Horizontal mode - fit within width
  // Count white keys
  const whiteKeys = keyEls.filter(k => !k.classList.contains('black'));
  const blackKeys = keyEls.filter(k => k.classList.contains('black'));
  const gaps = Math.max(0, whiteKeys.length - 1); // approx 1px gaps (margin-right:1px)
  const gapTotal = gaps * 1; // px
  // compute integer width per white key
  const whiteWidth = Math.max(28, Math.floor((containerWidth - gapTotal) / whiteKeys.length));
  // apply widths
  whiteKeys.forEach(k => {
    k.style.flex = `0 0 ${whiteWidth}px`;
    k.style.width = `${whiteWidth}px`;
    k.style.marginRight = '1px';
    k.style.marginLeft = '0';
  });
  // black key width ~ 62% of white
  const blackWidth = Math.max(18, Math.round(whiteWidth * 0.62));
  blackKeys.forEach(k => {
    k.style.flex = `0 0 ${blackWidth}px`;
    k.style.width = `${blackWidth}px`;
    // negative margins to overlay between whites (centered)
    const neg = Math.round(blackWidth / 2);
    k.style.marginLeft = `-${neg}px`;
    k.style.marginRight = `-${neg}px`;
  });
}

/* debounce helper */
let resizeTimer = null;
function onResizeDebounced(){
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=> adjustKeySizes(), 80);
}
window.addEventListener('resize', onResizeDebounced);

/* Toggle view (stacked / horizontal) */
document.getElementById('toggleView').addEventListener('click', ()=> {
  keyboardWrap.classList.toggle('stacked');
  // small delay to let CSS apply, then adjust sizes
  setTimeout(() => adjustKeySizes(), 50);
});

/* Also adjust after CSS/fonts load and after initial build */
window.addEventListener('load', ()=> adjustKeySizes());
setTimeout(()=> adjustKeySizes(), 120);

/* Clean up focus behavior */
keysContainer.addEventListener('focus', ()=> { /* nothing, keep focus */ });

</script>
</body>
</html>
